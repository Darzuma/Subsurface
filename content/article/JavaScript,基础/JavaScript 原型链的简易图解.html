title:JavaScript 原型链的简易图解（Prototype chain）
published:2019-07-31
lastEdited:2019-08-13
source:次表面
cover:images/articles/JavaScript,基础/prototype_2.gif
<!--divider-->
<section class="prologue">
    <p>
        JavaScript 对于“继承”和“多态”，没有直接的实现。
        面对子类、静态方法、class 值属性 等实际问题时，若不熟悉原型链，就会产生懵点。
        要熟练解决原型链相关问题，知道这三点即可：原型链图解、默认继承 和 [[Prototype]] 属性。
    </p>
</section>
<section>
        <h2>原型链的简易图解</h2>
        <img class="largeWidth" style="margin: 1.5rem auto 0 auto"
             src="__imageHost/images/articles/JavaScript,基础/prototype_2.gif">
        <small class="imgDescription">原型链的简易图解（
            <a href="https://subsurface.obs.cn-north-4.myhuaweicloud.com/images/articles/JavaScript,基础/prototype_1.png" target="_blank">
                点击获取高清静图
            </a>
            ）
        </small>
        <p>
            网络上常见的原型链图解，都被作图者主观复杂化了，《JS 高程》中的图示，更是复杂到望不可及。
            因此我将原型链的焦点（去掉了子类），<strong>以代码的形式模拟成图解</strong>，只需记住实例(Instance)、
            构造函数(Constructor)、Function 和 Object 四者间的原型关系即可。
        </p>
        <img class="fullWidth" style="margin: 2rem auto 0.2rem auto"
             src="__imageHost/images/articles/JavaScript,基础/prototype_6.png">
        <small class="imgDescription">
            （上图）原型链被一些作图者“主观复杂化”了
        </small>
    </section>
<section>
    <h2>所有引用类型默认都继承了 Object</h2>
    <p>
        《JS 高程》中着重强调：<strong>所有引用类型默认都继承了 Object</strong>，这是所有数据类型都会继承 toString()、 valueOf()等默认方法的原因。
    </p>
</section>
<section>
        <h2>__proto__ 是一个访问器属性</h2>
        <p>
            在原型链的实现上，虽然各平台都提供了 __proto__ 属性，但其本质是一个访问器属性，<strong>每次使用
            __proto__ ，都会调用其 getter 和 setter，实际访问的是对象内部的 [[Prototype]]，因此使用 __proto__
            会影响性能</strong>。
        </p>
        <p>
            MDN 建议使用 Object.create() 来创建原型对象，使用 Object.getPrototypeOf() 来获取原型。
        </p>
    </section>
<section>
        <h2>运算的结果，仅是运算逻辑的体现</h2>
        <p>
            <strong>Function 和 Object 的先后顺序，由 JavaScript 的实现者设定</strong>，ES 文档只描述语言的定义和功能，而《JS
            高程》中关于原型链的内容，通篇都在讲子类，两者都未提及原型链的实现。Function 和 Object
            的先后问题，近乎无案可查，其逻辑类似莫比斯循环，无始无终。我非常认同
            <strong><a href="https://www.zhihu.com/people/he-shi-jun/activities">@贺师俊</a>
                在此问中，提出过一个观点：运算的结果，仅是运算逻辑的体现</strong>，不一定是真相。
        </p>
        <p>
            <strong>警告！以下三方观点，均有“前后矛盾，不能自圆其说”之处。</strong>
        </p>
        <p>持 Object.prototype 观点者认为：<strong>Object.prototype 处于原型链的顶端（向上是
            null），无 constructor 属性</strong>，所以 Object.prototype 是凭空出现的。根据先有原型，后有实例的规律，
            持此观点者认为的出现顺序是：
        </p>
        <p style="text-indent:0;text-align: center">
            Object.prototype → Function.prototype → Function → Object
        </p>
        <img src="__imageHost/images/articles/JavaScript,基础/prototype_4.png"
             class="largeWidth" style="margin: 2rem auto 0.6rem auto">
        <small class="imgDescription" style="font-weight: bold;color: red">
            （上图）Object.prototype.__proto__ === null
        </small>
        <pre class="prettyprint">
    Object.prototype.__proto__ === null //true
    Object.prototype.constructor        //undefined
    //Object.prototype 向上查找是 null，也无 constructor 属性
</pre>
        <p>
            持 Object 观点认为：Object 是 Function.prototype 的构造者，而 Function 是所有对象的构造器。 持此观点者认为的出现顺序是：
        </p>
        <p style="text-indent:0;text-align: center">
            Object → Function.prototype → Function → Object.prototype
        </p>
        <img src="__imageHost/images/articles/JavaScript,基础/prototype_3.png"
             class="largeWidth" style="margin: 1.2rem auto 0.6rem auto">
        <small class="imgDescription" style="font-weight: bold;color: red">
            （上图）Function.prototype.__proto__ === Object.prototype
        </small>
        <pre class="prettyprint">
    Object.getPrototypeOf(Function.prototype) === Object.prototype
    //true
    Function.prototype.__proto__ === Object.prototype
    //true
    //结果是 true，就可凭此认定 Object 是 Function.prototype 的构造者吗？
</pre>
        <p>
            持 Function 观点认为：JS 设计之初，函数就是 First Class，Function 自己构造了自己，因为
            Function.__proto__ === Function.prototype，然后 Function 构造了 Object，因为 Object.__proto__ === Function.prototype。
            持此观点者认为的出现顺序是：
        </p>
        <p style="text-indent:0;text-align: center">
            Function → Function.prototype → Object
        </p>
        <img src="__imageHost/images/articles/JavaScript,基础/prototype_5.png"
             class="largeWidth" style="margin: 1.2rem auto 0.6rem auto">
        <small class="imgDescription" style="font-weight: bold;color: red">
            （上图）Function.__proto__ === Function.prototype
        </small>
        <pre class="prettyprint">
    Function.__proto__ === Function.prototype //true
    Object.__proto__ === Function.prototype   //true
</pre>
    <p>Function 和 Object 的先后顺序，是由 JavaScript 的实现者设定的，不由我们猜定。运算的结果，仅是运算逻辑的体现，不一定是事实。
    </p>
<!--    <div class="theEnd">- THE END -</div>-->
</section>

